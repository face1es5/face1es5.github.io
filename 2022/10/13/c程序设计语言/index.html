<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>almostSalted</title>
<meta name="referrer" content="no-referrer" />
<meta name="google-site-verification" content="_CsSd0yrTQQrdEyoybq1kZNTZbIVulPo3zdQnaqAR0Y" />
<link rel="stylesheet" href="/css/highlight/styles/monokai.min.css" />
  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
     
    <a href="/diary ">diary</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Chapter-2"><span class="anchor-number">1.</span> <span class="anchor-text">Chapter 2</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Shit"><span class="anchor-number">1.1.</span> <span class="anchor-text">Shit</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6"><span class="anchor-number">1.2.</span> <span class="anchor-text">删除指定字符</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#%E4%BE%8B%E9%A2%98"><span class="anchor-number">1.3.</span> <span class="anchor-text">例题</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Chapter-3"><span class="anchor-number">2.</span> <span class="anchor-text">Chapter 3</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Switch"><span class="anchor-number">2.1.</span> <span class="anchor-text">Switch</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="anchor-number">2.2.</span> <span class="anchor-text">例题</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Chapter-4"><span class="anchor-number">3.</span> <span class="anchor-text">Chapter 4</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="anchor-number">3.1.</span> <span class="anchor-text">KMP算法</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#the-fucking-GCC-x2F-G"><span class="anchor-number">4.</span> <span class="anchor-text">the fucking GCC&#x2F;G++</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#c-cpp-%E2%80%93-gt-executable-file"><span class="anchor-number">4.1.</span> <span class="anchor-text">.c .cpp –&gt; executable file</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="anchor-number">4.2.</span> <span class="anchor-text">预处理</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#%E7%BC%96%E8%AF%91"><span class="anchor-number">4.3.</span> <span class="anchor-text">编译</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#%E6%B1%87%E7%BC%96"><span class="anchor-number">4.4.</span> <span class="anchor-text">汇编</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#%E9%93%BE%E6%8E%A5"><span class="anchor-number">4.5.</span> <span class="anchor-text">链接</span></a></li></ol></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>c程序设计语言</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2022.10.13
      </div>
        
        <div class="postCategory">
            <a href="/categories/fuck/">fuck</a>
        </div>
         
    </div>
    <div id="postBody">
      <h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h2 id="Shit"><a href="#Shit" class="headerlink" title="Shit"></a>Shit</h2><p>关于这个b类型转换呢，在CSAPP上简单提了一嘴，一般是无符号的优先级比有符号高，也就是说表达式中如果既有有符号也有无符号，有符号会先隐式转换成无符号然后再计算.</p>
<p>比如说比较大小,<code>-1&gt;=(unsigned int)1000</code>，因为-1转成无符号是最大正整数.</p>
<p>本书里关于类型转换说的更具体了一点:</p>
<p>double &gt; float &gt; int &gt; char &amp; short &gt; long</p>
<p>不知道对不对，我没测试过啊，不是很想测</p>
<hr>
<p>还有这个b位扩展啊，提一嘴，决定符号扩展(高位填最高有效位)还是算术扩展(高位填0)的是原变量的符号性，例如</p>
<p><code>int a=(signed char)255;</code> <code>a</code>的结果是-1(-1的十六进制表达式<code>0xFFFFF...</code>)</p>
<h2 id="删除指定字符"><a href="#删除指定字符" class="headerlink" title="删除指定字符"></a>删除指定字符</h2><p>书上就有,双指针算法，还是相当经典的</p>
<pre><code class="cpp">void squeeze(string&amp; s, int c) &#123;
    int i, j;
    i = j = 0;
    for (; i &lt; s.size(); i++) &#123;
        if (s[i] != c)
            s[j++] = s[i];
    &#125;
    s[j] = &#39;\0&#39;;
    s.resize(j+1);
&#125;
</code></pre>
<p>i是快指针，j是慢指针，开始时ij指向同一元素，慢指针j只有在遇到不同于c的字符时才会前进，而i一直向后移动.最终j会指向剔除掉字符<code>c</code>的新数组的尾部(有效元素的后一位).</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><code>2-3</code> htoi,将十六进制转换成整数，有效数字为 0-9,a-f,A-F</p>
<pre><code class="cpp">int htoi(string s)&#123;
  int n=0;
  for(int i=0;
  i&lt;s.size() &amp;&amp; ((s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;) || (s[i]&gt;=&#39;a&#39; &amp;&amp; s[i]&lt;=&#39;f&#39;) || (s[i]&gt;=&#39;A&#39; &amp;&amp; s[i]&lt;=&#39;F&#39;));
  i++)&#123;
    int tmp=0;
    if (isdigit(s[i]))  //数字
      tmp=s[i]-&#39;0&#39;;
    else if (s[i]&gt;=&#39;a&#39;) //小写
      tmp=s[i]-&#39;a&#39;+10;
    else
      tmp=s[i]-&#39;A&#39;+10;
    n=n*16+tmp;
  &#125;
  return n;
&#125;
</code></pre>
<p>有点丑陋，将就看看…</p>
<hr>
<p><code>2-4</code> 重写squeeze(s1,s2),把字符串s1中与字符串s2中字符匹配的各个字符都删除.</p>
<p>不是很懂他想表达什么，如果是把s1和s2对应位置的相同字符删除的话，感觉和原版也没什么区别…</p>
<hr>
<p><code>2-9</code></p>
<pre><code class="cpp">int bitcount(unsigned int x)&#123;
    int sum=0;
    while(x)&#123;
        sum++;
        x&amp;=(x-1);
    &#125;
    return sum;
&#125;
</code></pre>
<hr>
<p><code>2-10</code></p>
<pre><code class="cpp">string lower(string s)&#123;
    for(int i=0;i&lt;s.size();i++)
        s[i]=(s[i]&gt;=&#39;a&#39; &amp;&amp; s[i]&lt;=&#39;z&#39;)?s[i]:s[i]+(&#39;a&#39;-&#39;A&#39;);
    return s;
&#125;
</code></pre>
<h1 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h1><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>switch的分支在匹配到某一分支后，如果该分支内没有用<code>break</code>等跳转语句退出，那么后续所有分支都会被依次执行.</p>
<hr>
<p>并列分支：</p>
<p><code>case 1: case 2: case 3: ...;break; case 4:...;break;</code></p>
<p>1,2,3这3种情况会进入同一分支.</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><code>3-1</code></p>
<p>很简单，只需要判断是否相等，然后利用三元运算符给左右边界赋值.</p>
<blockquote>
<p>三元运算符<code>?:</code>	<code>(exp1)?(exp2):(exp3)</code></p>
<p>exp1的值为真，则表达式整体的值为表达式2,否则为表达式3</p>
<p>因为是表达式，所以其实也可以进行赋值的操作，并且赋值表达式的值就是&#x3D;号左边变量的值</p>
</blockquote>
<pre><code class="cpp">int binsearch(int a[], int n, int v) &#123;
    int l, r, mid;
    l = 0;
    r = n - 1;
    while (l &lt;= r) &#123;
        mid = (l + r) / 2;
        if (a[mid] == v)
            return mid;
        a[mid] &lt; v ? (l = mid) : (r = mid);
    &#125;
    return -1;
&#125;
</code></pre>
<hr>
<p><code>3-2</code> 写的也太丑陋了</p>
<pre><code class="cpp">string escape(string s, string t) &#123;
    int i;
    i = 0;
    for (int j=0; j &lt; t.size(); j++) &#123;
        if (!isdigit(t[j]) &amp;&amp; !isalpha(t[j])) &#123;
            s.push_back(&#39;\\&#39;);
            switch (t[j]) &#123;
                case &#39;\a&#39;:
                    s.push_back(&#39;a&#39;);
                    break;
                case &#39;\b&#39;:
                    s.push_back(&#39;b&#39;);
                    break;
                case &#39;\f&#39;:
                    s.push_back(&#39;f&#39;);
                    break;
                case &#39;\n&#39;:
                    s.push_back(&#39;n&#39;);
                    break;
                case &#39;\r&#39;:
                    s.push_back(&#39;r&#39;);
                    break;
                case &#39;\t&#39;:
                    s.push_back(&#39;t&#39;);
                    break;
                case &#39;\v&#39;:
                    s.push_back(&#39;v&#39;);
                    break;
                default:
                    break;
            &#125;
        &#125; else &#123;
            s.push_back(t[j]);
        &#125;
    &#125;
    return s;
&#125;
</code></pre>
<hr>
<p><code>3-4</code> 在数的反码表示中，<code>itoa</code>不能处理最大的负数，原因是:</p>
<p>有符号整数(例如<code>int</code>)的存储方式是补码，0作为非负数但实际上以正数的形式存储，所以负数的表示范围要比正数多1,例如16位有符号数的范围是<code>-32768 ~ 32767</code></p>
<p>至于修改嘛，举个例子,可以把<code>-32768</code>先变为<code>32767</code>,然后把个位上的数字++后再转化成字符，因为一共就这么一种特殊情况,我懒得写了.</p>
<hr>
<p><code>3-5</code> itob(n,b),把整数n转为b进制的字符串</p>
<pre><code class="cpp">string itob(int n, int b) &#123;
    if (b&gt;36)&#123;
        cout&lt;&lt;&quot;对不起,最高支持36进制,cnm&quot;&lt;&lt;endl;
        return &quot;&quot;;
    &#125;else if (b&lt;0)&#123;
        cout&lt;&lt;&quot;司马了?&quot;&lt;&lt;endl;
        return &quot;&quot;;
    &#125;

    string s;
    bool sign = false;
    if (n &lt; 0 &amp;&amp; (sign = true))
        n = -n;
    do &#123;
        if (n % b &lt; 10)
            s.push_back((char)(n % b + &#39;0&#39;));
        else  //高于10进制
            s.push_back((char)(n % b - 10 + &#39;A&#39;));
    &#125; while ((n /= b) &gt; 0);
    if (sign)
        s.push_back(&#39;-&#39;);
    reverse(s);
    return s;
&#125;
</code></pre>
<h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h1><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52622200/article/details/110563434">参考,小伙子讲的挺好的</a></p>
<p>kmp算法的比较过程其实很好理解，但是构建<code>next</code>数组的过程是在是太几把抽象了.</p>
<p>我理解的也不是很到位，简单讲两句，具体是哪两句呢，是这两句，也不是很重，但我相信，这两句，也应该是要比那两句要强的:</p>
<blockquote>
<p>构建<code>next</code>数组的过程其实和比较的过程很像,可以把构建过程的两个指针所指向的子字符串(左<code>j</code>右<code>i</code>,s<sub>0~j</sub>和s<sub>i-j~i</sub>,待比较的字符是s<sub>i</sub>和s<sub>j</sub>)分离出来，想象成是在s<sub>0~j</sub>和s<sub>i-j~i</sub>中寻找匹配相等子串，并且s<sub>0~j-1</sub>和s<sub>i-j~i-1</sub>是相同的(你要问我为什么相同，我只能说算法确保了这一点…)</p>
<p>有了前缀条件s<sub>0~j-1</sub>=&#x3D;s<sub>i-j~i-1</sub>,显然如果s<sub>j</sub>=&#x3D;s<sub>i</sub>,那么next<sub>i+1</sub>&#x3D;j+1</p>
<p>至于为什么s<sub>0~j-1</sub>=&#x3D;s<sub>i-j~i-1</sub>,是因为代码里有这么一句 j&#x3D;next<sub>j</sub></p>
</blockquote>
<p>附kmp算法代码:</p>
<pre><code class="cpp">void getNext(string s, int* next) &#123;
    next[0] = -1;
    int i = 0, j = -1;
    while (i &lt; s.size() - 1) &#123;
        if (j == -1 || s[i] == s[j])
            next[++i] = ++j;
        else
            j = next[j];
    &#125;
&#125;

int strindex(string haystack, string needle) &#123;
    if (haystack.size() &lt;= 0)
        return -1;
    else if (needle.size() == 0)
        return 0;

    int next[needle.size()];
    getNext(needle, next);

    int i = 0, j = 0;	//j是从0开始的哦
    //草泥马,不强制转换成int j==-1就会直接跳出循环
    while (i &lt; haystack.size() &amp;&amp; j &lt; (int)needle.size()) &#123;
        // j==-1的情况是压根没有重叠的部分,所以hay和needle的指针都后移
        if (j == -1 || haystack[i] == needle[j])
            i++, j++;
        else
            j = next[j];
    &#125;
    if (j == needle.size())  //匹配成功
        return i - j;
    return -1;
&#125;
</code></pre>
<h1 id="the-fucking-GCC-x2F-G"><a href="#the-fucking-GCC-x2F-G" class="headerlink" title="the fucking GCC&#x2F;G++"></a>the fucking GCC&#x2F;G++</h1><p>剑比gcc默认没有man page，我真是操了你妈了<br>真无语</p>
<h2 id="c-cpp-–-gt-executable-file"><a href="#c-cpp-–-gt-executable-file" class="headerlink" title=".c .cpp –&gt; executable file"></a>.c .cpp –&gt; executable file</h2><p>一个c程序需要经过</p>
<ul>
<li>预处理</li>
<li>编译</li>
<li>汇编</li>
<li>链接<br>这四个过程，最终生成可执行文件</li>
</ul>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>类似#xxx的语句会在这一阶段进行处理，例如<code>\#include</code>会将目标文件内容全部赋值过来<br>宏<code>\#define</code>会替换符号<br>还有<code>\#if \#pragma</code>之类的就不介绍了，比较杂…</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>好吧，虽然上面说的四个过程合起来可以简称为编译，但这里的编译指的是把源文件编译成汇编语言(汇编语言是二进制的可读形式)</p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>这一步会把汇编文件转变为目标文件(.o),也就是转换成2进制<br>,但是不会链接</p>
<blockquote>
<p>对应 <code>gcc -c</code></p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>将多个目标文件链接成最终的可执行文件,静态库也会在这一步被合并进来.<br>我简单解释一下链接的作用，在源程序中可能调用了别的文件定义的变量，函数，以及库函数，这些东西统称为外部调用<br>在汇编阶段不会处理外部调用，因为汇编是针对单个文件的，所以还不知道外部调用对应的具体地址<br>在链接阶段所有目标文件已经准备就绪，链接器(例如ld)会处理所有的外部符号(就是外部变量，外部函数的名字),把地址确定下来,最终所有文件会被整合成一个大的可执行文件.<br>(至于动态库的内容，别指望我说，我也不是很会)</p>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">



<script src="/js/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>

<div id="footer"></div>
 
</body>
<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>False</title>
<meta name="referrer" content="no-referrer" />
<meta name="google-site-verification" content="_CsSd0yrTQQrdEyoybq1kZNTZbIVulPo3zdQnaqAR0Y" />
<link rel="stylesheet" href="/css/highlight/styles/monokai.min.css" />
  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Learn-Lisp-The-Hard-Way-Second-Draft-In-Progress"><span class="anchor-number">1.</span> <span class="anchor-text">Learn Lisp The Hard Way(Second Draft, In-Progress)</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Second-Draft-in-progress"><span class="anchor-number">1.1.</span> <span class="anchor-text">Second Draft (in-progress)</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#About-the-Author"><span class="anchor-number">1.1.1.</span> <span class="anchor-text">About the Author</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Supoprting-This-Project"><span class="anchor-number">1.1.2.</span> <span class="anchor-text">Supoprting This Project</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Recent-Updates"><span class="anchor-number">1.1.3.</span> <span class="anchor-text">Recent Updates</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Issues"><span class="anchor-number">1.1.4.</span> <span class="anchor-text">Issues</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Past-Contributors"><span class="anchor-number">1.1.5.</span> <span class="anchor-text">Past Contributors</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#CHANGELOG"><span class="anchor-number">1.2.</span> <span class="anchor-text">CHANGELOG</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#TODO"><span class="anchor-number">1.3.</span> <span class="anchor-text">TODO</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#FAQ"><span class="anchor-number">1.4.</span> <span class="anchor-text">FAQ</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#PREFACE"><span class="anchor-number">2.</span> <span class="anchor-text">PREFACE</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#TANSTAAFL"><span class="anchor-number">2.1.</span> <span class="anchor-text">TANSTAAFL</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#The-Hard-Way-is-Easier"><span class="anchor-number">2.2.</span> <span class="anchor-text">The Hard Way is Easier</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Reading-and-Writing"><span class="anchor-number">2.2.1.</span> <span class="anchor-text">Reading and Writing</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Attention-to-Detail"><span class="anchor-number">2.2.2.</span> <span class="anchor-text">Attention to Detail</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Spotting-Diffrences"><span class="anchor-number">2.2.3.</span> <span class="anchor-text">Spotting Diffrences</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Mathematics"><span class="anchor-number">2.2.4.</span> <span class="anchor-text">Mathematics</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#No-Copy-and-Paste"><span class="anchor-number">2.2.5.</span> <span class="anchor-text">No Copy-and-Paste</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Who-is-This-Book-For"><span class="anchor-number">2.3.</span> <span class="anchor-text">Who is This Book For?</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Configuring-Your-Development-Environment"><span class="anchor-number">2.4.</span> <span class="anchor-text">Configuring Your Development Environment</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Working-from-the-Command-Line"><span class="anchor-number">2.4.1.</span> <span class="anchor-text">Working from the Command-Line</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Installing-SBCL"><span class="anchor-number">2.4.2.</span> <span class="anchor-text">Installing SBCL</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-4"><a class="anchor-link" href="#Windows"><span class="anchor-number">2.4.2.1.</span> <span class="anchor-text">Windows</span></a></li><li class="anchor-item anchor-level-4"><a class="anchor-link" href="#macOS"><span class="anchor-number">2.4.2.2.</span> <span class="anchor-text">macOS</span></a></li><li class="anchor-item anchor-level-4"><a class="anchor-link" href="#Linux"><span class="anchor-number">2.4.2.3.</span> <span class="anchor-text">Linux</span></a></li><li class="anchor-item anchor-level-4"><a class="anchor-link" href="#Debian-x2F-Ubuntu"><span class="anchor-number">2.4.2.4.</span> <span class="anchor-text">Debian&#x2F;Ubuntu</span></a></li></ol></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Installing-Quicklisp"><span class="anchor-number">2.4.3.</span> <span class="anchor-text">Installing Quicklisp</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Choosing-a-Text-Editor"><span class="anchor-number">2.4.4.</span> <span class="anchor-text">Choosing a Text Editor</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Lisp-A-Future-History"><span class="anchor-number">2.5.</span> <span class="anchor-text">Lisp: A Future History</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#A-Technology-Driven-Cultrue"><span class="anchor-number">2.5.1.</span> <span class="anchor-text">A Technology Driven Cultrue</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Programming-Languages-Today"><span class="anchor-number">2.5.2.</span> <span class="anchor-text">Programming Languages Today</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#The-Lisp-Community"><span class="anchor-number">2.5.3.</span> <span class="anchor-text">The Lisp Community</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Lisp-Consciousness"><span class="anchor-number">2.5.4.</span> <span class="anchor-text">Lisp Consciousness</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Convergence-Theory-and-the-Technological-Singularity"><span class="anchor-number">2.5.5.</span> <span class="anchor-text">Convergence Theory and the Technological Singularity</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Acknowledgements"><span class="anchor-number">2.6.</span> <span class="anchor-text">Acknowledgements</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#PART-ONE-GROKKING-LISP"><span class="anchor-number">3.</span> <span class="anchor-text">PART ONE: GROKKING LISP</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Overview"><span class="anchor-number">3.1.</span> <span class="anchor-text">Overview</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Chapter-1-Common-Lisp-Bootcamp"><span class="anchor-number">3.2.</span> <span class="anchor-text">Chapter 1: Common Lisp Bootcamp</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Syntax-Overview-in-5-Minutes"><span class="anchor-number">3.2.1.</span> <span class="anchor-text">Syntax Overview in 5 Minutes</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#The-REPL"><span class="anchor-number">3.2.2.</span> <span class="anchor-text">The REPL</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Expressions-Parentheses-and-Return-Values"><span class="anchor-number">3.2.3.</span> <span class="anchor-text">Expressions, Parentheses, and Return Values</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Lists-Cons-Cells-and-Memory"><span class="anchor-number">3.2.4.</span> <span class="anchor-text">Lists, Cons-Cells, and Memory</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Symbols-and-Namespaces"><span class="anchor-number">3.2.5.</span> <span class="anchor-text">Symbols and Namespaces</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Prefix-Notation"><span class="anchor-number">3.2.6.</span> <span class="anchor-text">Prefix Notation</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Common-Lisp-Style-Guide"><span class="anchor-number">3.2.7.</span> <span class="anchor-text">Common Lisp Style Guide</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-4"><a class="anchor-link" href="#Symblos-and-Naming"><span class="anchor-number">3.2.7.1.</span> <span class="anchor-text">Symblos and Naming</span></a></li></ol></li></ol></li></ol></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>LEARN LISP THE HARD WAY</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2023.4.23
      </div>
        
        <div class="postCategory">
            <a href="/categories/lisp/">lisp</a>
        </div>
         
    </div>
    <div id="postBody">
      <h1 id="Learn-Lisp-The-Hard-Way-Second-Draft-In-Progress"><a href="#Learn-Lisp-The-Hard-Way-Second-Draft-In-Progress" class="headerlink" title="Learn Lisp The Hard Way(Second Draft, In-Progress)"></a>Learn Lisp The Hard Way(Second Draft, In-Progress)</h1><h2 id="Second-Draft-in-progress"><a href="#Second-Draft-in-progress" class="headerlink" title="Second Draft (in-progress)"></a>Second Draft (in-progress)</h2><div style="text-align:center;">by</div>

<p>&quot;the Phoeron Colin J.E. Lupton&quot;</p>
<div style="text-align:center;">translated by</div>

<p>&quot;我&quot;</p>
<pre><code class="lisp">;;Welcome to L((λ)THW!
(let ((llthw &#39;(learn lisp the hard way)&#39;)))
(format t&quot;~&#123;~@(~A~)~^ ~&#125;, because ~(~A~^ ~) is easier~&quot;)
;; Common Lisp: Powerful, Expressive, Programmable, General Purpose, Multi-Paradigm.
</code></pre>
<h3 id="About-the-Author"><a href="#About-the-Author" class="headerlink" title="About the Author"></a>About the Author</h3><p>...</p>
<h3 id="Supoprting-This-Project"><a href="#Supoprting-This-Project" class="headerlink" title="Supoprting This Project"></a>Supoprting This Project</h3><p>...</p>
<h3 id="Recent-Updates"><a href="#Recent-Updates" class="headerlink" title="Recent Updates"></a>Recent Updates</h3><p>...</p>
<h3 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h3><p>...</p>
<h3 id="Past-Contributors"><a href="#Past-Contributors" class="headerlink" title="Past Contributors"></a>Past Contributors</h3><p>...</p>
<h2 id="CHANGELOG"><a href="#CHANGELOG" class="headerlink" title="CHANGELOG"></a>CHANGELOG</h2><p>...</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>...</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>...</p>
<h1 id="PREFACE"><a href="#PREFACE" class="headerlink" title="PREFACE"></a>PREFACE</h1><h2 id="TANSTAAFL"><a href="#TANSTAAFL" class="headerlink" title="TANSTAAFL"></a>TANSTAAFL</h2><blockquote>
<p>&quot;There Ain&#39;t No Such Thing As A Free Lunch...anything free costs twice as much in the long run or turns out worthless.&quot;</p>
<p>Robert A. Heinlein, The Moon Is A Harsh Mistress</p>
</blockquote>
<p>编程很难.说它不难的人要么试图让你觉得你不如他们，要么是想卖东西给你.对于许多&quot;容易学习&quot;的编程语言来说，这两者是同时存在的.But you&#39;re not here for inefficient, glorified, instant-gratification scripting languages that pigeon-hole you into prescribed execution control-flows and common use cases.你在这里不是为了学习即使完成最简单的任务也要被驯服的单体命令式语言.你已经找到了<strong>艰难的路</strong>,以及最难掌握的语言,Common Lisp.你并不害怕为了你想要的而努力，抑或致力于一种新的思考方式---你在这里是因为你想成为一名Lisp Hacker,任何事情都不能阻挡你的脚步.</p>
<p>话虽如此，学习Lisp并不是一个无法实现的梦想.就像很多技能一样，熟能生巧---这就是<strong>艰难之路</strong>的意义所在.Lisp可能看起来像一个古老而神秘的秘密，由精英黑客组成的不可逾越的小集团所珍惜保护，但是就像人们普遍把这门语言和人工智能联系在一起一样，这是一个误解.你不必是一个天才或者黑帽，就能破解围绕Lisp和它所兴起的开源亚文化的谜团.你只需要遵循几个基本步骤，并切实地应用它们.</p>
<p>Lisp最大秘密是它是所有已创造出来的编程语言中最简单的那一个---再加上它强大的表达能力以及优雅,就是它为什么只受到世界上最好的程序员青睐的原因.努力，注重细节，以及对主题材料的自习思考，你就能使用Lisp比其他较次的编程语言更早地写出真正的应用.</p>
<h2 id="The-Hard-Way-is-Easier"><a href="#The-Hard-Way-is-Easier" class="headerlink" title="The Hard Way is Easier"></a>The Hard Way is Easier</h2><blockquote>
<p>&quot;产生新想法最困难的地方在于需要扫除占据利基位置的错误想法.只要利基位置还被占据，证据，证明和逻辑推演就无处可去.但是一旦填充在利基位置里的错误想法被清空---一旦你可以诚实地说,&#39;我不知道&#39;,那么就有可能获得真理.&quot;</p>
<p>Robert A. Heinlein, The Cat Who Walks Through Walls</p>
</blockquote>
<p>无论你认为自己多么了解编程，请忘掉它.Lisp和其他的编程语言不一样.</p>
<p>如果你作为一位有经验的开发者来学习Lisp，为了公平起见，我得先告诉你，你的经验可能会拖你的后腿.当材料没有在&quot;挑战你&quot;的时候，你的经验会让你觉得这很无聊.它会让你跳过你认为你已经掌握的部分.它会告诉你阅读一次代码样例就足够掌握它了,复制粘贴没什么问题.<em>但是这种经历是一个谎言</em>.如果你在现在松懈，只会让后面的东西更难.</p>
<p>无论你是谁抑或你的背景如何，如果你紧跟教材的脚步，从长远来看，就能更容易.你不得不努力，但是你会第一次学到你所需要学到的东西，并且你永远不会忘记.</p>
<p>艰难的学习方式意味着每天遵循以下五个步骤，直到你完成这本书:</p>
<ol>
<li>忘掉你知道的一切</li>
<li>从头到尾完成每个练习</li>
<li>准确地输入每个示例</li>
<li>让代码能跑</li>
<li>反思你看到的东西</li>
</ol>
<p>这就是全部.</p>
<p>根据你自律的级别，你可能比一些人更难坚持这些步骤---但是这又不是竞赛.不必担心完成一个练习会花多久，如果你错过了一天，不要惊慌，也不要把自己和别人比较.如果你每天尽最大努力去实施这些步骤，就能发展出把这本书看完所需要的自律性.</p>
<p>该书的一个重要主题还有在使用Lisp时，将会普遍强化编程所需要的必要技能.这些技能是: 阅读和写作，细心，发现差异，以及数学.因此你一旦完成这本书，你就不只是一个Lisp黑客，你还能对付其他编程语言---然后，在过程中你可能发现学习一项新技能比任何爱好，电影或者tv秀更有意思.</p>
<h3 id="Reading-and-Writing"><a href="#Reading-and-Writing" class="headerlink" title="Reading and Writing"></a>Reading and Writing</h3><p>编程，就像人类语言一样，涉及到有意使用一套特定的、与语言相关的、有意义的字符，其中有些字符你可能不习惯打.编程比人类语言精确的多---如果你阅读，写作或者打字有问题，那么你敲代码就有困难.</p>
<p>花点时间仔细阅读代码例子，在打完字后反复检查你的工作.这会让你减少很多压力.</p>
<h3 id="Attention-to-Detail"><a href="#Attention-to-Detail" class="headerlink" title="Attention to Detail"></a>Attention to Detail</h3><p>相比其他技能，在各个领域和行业中，专家与门外汉的区别在于对细节的关注.在编程领域，这尤其显然;细节是一个性能欠佳且bug，经常崩溃，导致其用户很烦躁的软件与一个精致，对用户友好且不可或缺的软件之间的区别.</p>
<p>在学习这本书的过程中手动准确地输入每一个练习，你会训练你的大脑在做这件事时专注于你做的事情的微妙细节.</p>
<h3 id="Spotting-Diffrences"><a href="#Spotting-Diffrences" class="headerlink" title="Spotting Diffrences"></a>Spotting Diffrences</h3><p>前两个技能的自然延伸是发现不同的能力.通过仔细阅读，打字，以及对细节的专注，你还会训练你的大脑为你强调细微的不同，因此当你犯错的时候，你会注意到，并且能立即修正它.</p>
<p>当然，这一技能还会帮助你更快发现和修正在你不得不升级和维护的其他人的代码中的bug.</p>
<h3 id="Mathematics"><a href="#Mathematics" class="headerlink" title="Mathematics"></a>Mathematics</h3><p>还记得在高中，总是至少有一个同学会知道，在生活中，你们中的任何一个在什么时候需要知道他们教给你的一半知识?你可能曾经是那种学生，如果是，那你可能很失望地知道，一个专业程序员每天需要解决的许多问题领域几乎需要整个高中和大学领域的数学课程.我不是在谈论高度专业化的领域，例如两字计算，货币，股票和商品交易所，或者密码学---小游戏，手机和网络开发者同样需要数学.就像zed shaw在一篇杰出，尽管有很多高强度互动的文章里说的，程序员至少要知道统计学.但是代数，几何学，三角函数，微积分，Lambda演算---当然还有算法---都是极其有用的工具，可以帮助你在一个全新的层面上思考以及抽象你的代码.</p>
<p>如果一提到数学，你的心跳就加快，手抖，冒冷汗，只需要想一下银河系漫游指南封面上的话：不要害怕.学习编程或者Lisp，不需要你是一个数学天才，并且本书假定读者对小学以上的数学知识不熟悉.在你需要的时候，你可以顺便学习一下数学---并且这一次你很可能理解的更好，因为你看到了它的实际运用.只需要记住数学是你的朋友---即使当它不重要的时候，形式定量推理，分析，以及演绎推理将会让你比其他开发者更有优势，并且帮助你写出更棒的软件.Oh right, and <em>make sure you know where your towel is.</em></p>
<h3 id="No-Copy-and-Paste"><a href="#No-Copy-and-Paste" class="headerlink" title="No Copy-and-Paste"></a>No Copy-and-Paste</h3><p>如果你只是把例子复制到Lisp解释器中，而不是自己动手写，这就和完全没做一样.在本书期间，我既是老师也是学生，你得强迫自己手动写每一个例子.无论例子多简单或者看起来多么不言自明，你必须阻止自己作弊.</p>
<p>这些练习重点在于训练你的手，眼睛，大脑，以及你的思维如何阅读，写作，观察，思考，以及dream code(我是没动这个词什么意思).当你作弊的时候，你只是为了作弊而作弊.</p>
<h2 id="Who-is-This-Book-For"><a href="#Who-is-This-Book-For" class="headerlink" title="Who is This Book For?"></a>Who is This Book For?</h2><p>感觉不重要，不想翻.</p>
<h2 id="Configuring-Your-Development-Environment"><a href="#Configuring-Your-Development-Environment" class="headerlink" title="Configuring Your Development Environment"></a>Configuring Your Development Environment</h2><p>在通过1.1章一头扎进Common Lisp之前，先花点时间配置一下开发环境,这样就可以专注于代码了.许多配置选项都只是个人品味，而且有很多可用的Common Lisp语言的杰出实现,但是鉴于本书的目的，我们会坚持使用最小化方案: 在命令行里使用SBCL以及一个纯文本编辑器.</p>
<h3 id="Working-from-the-Command-Line"><a href="#Working-from-the-Command-Line" class="headerlink" title="Working from the Command-Line"></a>Working from the Command-Line</h3><p>作为开发者，重要的是能自如地在命令行下工作.对于这本书而言，我们会专注于从命令行使用Lisp，不会使用某些shell自身带有的高级功能，所以你可以选择你喜欢的，或者系统自带的也行.</p>
<p>如果你从来没用过shell,PowerShell 7是一个开源，跨平台，使用门槛低，并且免费，你可以用它快速入门，然后把你的技能运用到任何环境中.Windows，Linux，macOS平台都能使用.</p>
<p>PowerShell 7文档，包括下载和安装指南在这:</p>
<p><a target="_blank" rel="noopener" href="https://microsoft.com/powershell">https://microsoft.com/powershell</a></p>
<p>Mac,linux,unix以及bsd通常提供开箱即用的bash，并且支持其他shell比如zsh.</p>
<p>windows自带古老的powershell 5.1，以及dos cmd，但是建议升级到powershell 7，或者使用自带bash的wsl(windows subsystem for linux).</p>
<h3 id="Installing-SBCL"><a href="#Installing-SBCL" class="headerlink" title="Installing SBCL"></a>Installing SBCL</h3><p>Stell Bank Common Lisp,简称SBCL,是最容易使用和运行的Lisp实现之一---免费而且开源，开发积极，支持很多平台,被认为是最稳定的Lisp开源可用实现.鉴于它会自动编译任何输入到REPL的内容，相比其他Lisp，运行中的Lisp进程也能得到速度提升.</p>
<blockquote>
<p>The SBCL REPL is minimal by design, since it is primarily used from within Emacs+SLIME which provides its own custom prompt, history, completion, multi-line editing capabilities, and more. In order to use it effectively straight from the command-line, you will need to install a separate tool on macOS and Linux called <code>rlwrap</code>, a readline wrapper. It provides evaluation history, multi-line editing, and can be configured for completions and filters. You can read more about <code>rlwrap</code> here:  <a target="_blank" rel="noopener" href="https://github.com/hanslub42/rlwrap">https://github.com/hanslub42/rlwrap</a></p>
</blockquote>
<p>更多有关SBCL的信息在这里:<a target="_blank" rel="noopener" href="https://sbcl.org/">https://sbcl.org/</a></p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在官方网站有32位和64位版本.</p>
<p>下载后可以从开始菜单运行SBCL,或者从cmd&#x2F;powershell运行.</p>
<h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p>在macOS,可以通过Homebrew安装SBCL的最新版本:</p>
<pre><code class="bash">$ brew install sbcl
</code></pre>
<p>你还可以安装<code>rlwrap</code>:</p>
<pre><code class="bash">$ brew install rlwrap
</code></pre>
<p>然后可以从终端运行SBCL:</p>
<pre><code class="bash">$ rlwrap sbcl
</code></pre>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>大多数Linux分发版在官方软件仓库里都有最新版本的SBCL,你可以用系统的包管理软件安装它.</p>
<p>还可以安装<code>rlwrap</code>,然后从shell中运行:</p>
<pre><code class="bash">$ rlwrap sbcl
</code></pre>
<h4 id="Debian-x2F-Ubuntu"><a href="#Debian-x2F-Ubuntu" class="headerlink" title="Debian&#x2F;Ubuntu"></a>Debian&#x2F;Ubuntu</h4><p>在Apt里的SBCL版本已经严重过时，所以如果你用的是Debian或者Ubuntu,可能要做一点额外的工作.</p>
<p>首先用Apt安装可用的SBCL.</p>
<p>然后用这个旧版本的SBCL,从源代码编译最新版本的SBCL.</p>
<h3 id="Installing-Quicklisp"><a href="#Installing-Quicklisp" class="headerlink" title="Installing Quicklisp"></a>Installing Quicklisp</h3><p>安装完SBCL并且运行后，第一件事是安装quicklisp.这是Lisp的包管理器，允许你动态加载社区支持的库(通常包含ASDF系统以及相关Lisp包)到你的Lisp镜像中.它可以自动处理你现有的Lisp项目的依赖.</p>
<p>从命令行下载Quicklisp安装脚本以及签名密钥:</p>
<pre><code class="bash">$ curl -O https://beta.quicklisp.org/quicklisp.lisp
$ curl -O https://beta.quicklisp.org/quicklisp.lisp.asc
</code></pre>
<p>在运行前先验证下载的签名密钥:</p>
<pre><code class="sh">$ gpg --verify quicklisp.lisp.asc quicklisp.lisp
</code></pre>
<p>如果验证成功，就可以启动SBCL同时加载安装脚本:</p>
<pre><code class="sh">$ rlwrap sbcl --load quicklisp.lisp
</code></pre>
<p>然后你会发现自己在Lisp REPL里，伴随一些指令:</p>
<pre><code class="lisp">  ==== quicklisp quickstart loaded ====

    To continue, evaluate: (quicklisp-quickstart:install)
</code></pre>
<p>遵循指令，在REPL里输入以下代码:</p>
<pre><code class="lisp">* (quicklisp-quickstart:install)
</code></pre>
<p>在完成依赖下载以及设置完工作目录后，它会提示你下载已完成.现在你可能想要在每次启动SBCL时自动加载它:</p>
<pre><code class="lisp">* (ql:add-to-init-file)
</code></pre>
<p>这一函数会在改变lisp <code>*.rc</code>文件之前告诉你它实际上做了什么.如果准备好了，输入回车键然后开始运行.</p>
<p>这样就完成了!现在可以使用<code>ql:system-apropos</code>来搜索库，以及<code>ql:quickload</code>来下载并安装库.</p>
<p>你可以把Lisp项目放在<code>~/quicklisp/local-projects/</code>里，这样quicklisp可以自动找到它们.然后你就能像加载其他用Quicklisp发布的库一样加载自己的项目.</p>
<h3 id="Choosing-a-Text-Editor"><a href="#Choosing-a-Text-Editor" class="headerlink" title="Choosing a Text Editor"></a>Choosing a Text Editor</h3><p>All you need to get started with Lisp is a simple, no-frills text editor with syntax highlighting, so that you can focus on learning Lisp itself and not get distracted by fiddling with an unfamiliar environment. A few worth checking out are:</p>
<ul>
<li>For Windows, macOS, and Linux:<ul>
<li>VSCode</li>
<li>Sublime Text</li>
<li>Atom</li>
<li>UltraEdit</li>
<li>gedit</li>
</ul>
</li>
<li>macOS only<ul>
<li>BBEdit</li>
</ul>
</li>
<li>Windows only<ul>
<li>Notepad++</li>
</ul>
</li>
</ul>
<p>Your favourite existing text editor should also be fine, just make sure it has syntax highlighting for Lisp and stays out of your way.</p>
<h2 id="Lisp-A-Future-History"><a href="#Lisp-A-Future-History" class="headerlink" title="Lisp: A Future History"></a>Lisp: A Future History</h2><blockquote>
<p>&quot;The future is better than the past. Despite the crepehangers, romanticists, and anti-intellectuals, the world steadily grows better because the human mind, applying itself to environment, makes it better. With hands...with tools...with horse sense and science and engineering.&quot;</p>
<p>Robert A. Heinlein, <em>The Door Into Summer</em></p>
</blockquote>
<p>许多在售的关于Common Lisp的书籍会在开头回顾Lisp的历史.这很明智，因为Lisp语言家族有着如此悠久和丰富的血脉，有很多可以说.然而与其写出另一种回顾过去的内容，我更希望从我的视角分享lisp的历史。如果Lisp的历史以及社区文化吸引到你了，也应如此，请看看列在本网站Resources部分之下的书籍，都很不错。</p>
<h3 id="A-Technology-Driven-Cultrue"><a href="#A-Technology-Driven-Cultrue" class="headerlink" title="A Technology Driven Cultrue"></a>A Technology Driven Cultrue</h3><p>人类社会总是一种科技推动型文化。在历史的每个时期，社会总是被创新所推动发展，ever since the very beginning of history when the ancient Sumerians first began carving words into clay tablets, to capture and preserve the fleeting vocalizations that would otherwise be lost in time the moment they had been spoken. Even that innovation was not enough for them---they kept pushing the boundaries of what writing could do, from the very first accounting records to the hero&#39;s journey of Gilgamesh.</p>
<p>We are no different today---we build on the work of those who came before us, we adapt and modify what already exists to suit our needs at the time, and sometimes, we stumble upon an innovation so important that it changes the world. John McCarthy&#39;s first paper on Lisp was such an innovation.</p>
<blockquote>
<p>妈的神神叨叨的。。。</p>
<p>感觉像在读散文，我根本看不下去这种矫情的b文字。。。</p>
</blockquote>
<h3 id="Programming-Languages-Today"><a href="#Programming-Languages-Today" class="headerlink" title="Programming Languages Today"></a>Programming Languages Today</h3><p>如今，Common Lisp仍在编程世界设定标准，鉴于还没有一门语言可以从速度、表达能力、交互性以及功能角度与其相匹配。每隔一段时间，一门新的编程语言出现，或者是新瓶装旧酒，用改变游戏规则的创新的空洞承诺来吸引软件开发人员和系统架构师；与此同时，Lisp黑客在私下里嘲笑科技界外围开发者的天真。</p>
<p>具体来说，像Swift，python，c++11以及java 8这样的语言最近一直在吹嘘它们的突破性新特性，这里仅举几个例子，例如泛型，函数式编程结构，lambda表达式，流，以及尾部调用优化。所有的这些特性都早已在1980年代的Common Lisp的ANSI标准化中建立，ps还有更多。Lisp黑客早已使用这些特性几十年了，并进一步推动创新。</p>
<p>然而，由于编程界的流行观点，例如&quot;Lisp古老又粗糙&quot;，抑或&quot;普遍程序员难以学习Lisp&quot;，Lisp社区变得越来越小，雇佣Lisp黑客也越来越贵。结果是，许多公司害怕把Lisp作为一个项目的编程语言，即使Lisp显然是最佳选择。类似C++，Java，.NET,Ruby或者Python之类的选择更受青睐，尽管这些又很多缺点和臭名昭著的bug。</p>
<p>但是世界上有一些公司已经改变了他们的观点---他们受够了营销噱头，受够了为漏洞百出，需要每天打安全补丁的专用平台、语言、IDE付费，受够了用如此不稳定的语言构建产品线，以至于每当有这种更新就得重写代码中的大部分内容，受够了感觉每一种新编程语言都只是数字万金油。他们想要一个到处都一样的平台，写出在安全更新之间也不会被破坏的代码，构建出经得起时间考验的产品。结果是越来越多的公司把Lisp作为最终答案---唯一的问题是现在没有足够的Lisp黑客流通。</p>
<h3 id="The-Lisp-Community"><a href="#The-Lisp-Community" class="headerlink" title="The Lisp Community"></a>The Lisp Community</h3><p>相比于python或者haskell，lisp社区尽管相对较小，但是更友好。大部分是因为Lisp语言自身比较包容，支持世界上每一种程序模式，并且容易让Lisp黑客创造和实现自己的模式。</p>
<h3 id="Lisp-Consciousness"><a href="#Lisp-Consciousness" class="headerlink" title="Lisp Consciousness"></a>Lisp Consciousness</h3><p>(散文，懒得翻...)</p>
<p>There&#39;s just something about Lisp---it changes the way you think, the way you see the world, the way you act. Lisp Hackers have long known and proudly vocalized the near-mystical experience that comes with writing software in this language; they have adopted the Heinleinian terminology of &#39;grokking&#39; to describe the state of consciousness a programmer achieves when they stop just writing code in Lisp and start becoming one with their software; they have incorporated religious and mystical concepts from Gnosticism, Zen Buddhism, Hinduism, Sufism, and Western Occultism into the Lisp mythos. Lisp teachers cannot simply teach a programming language as any other is taught; no, they feel compelled by a fire in their hearts to <em>preach the gospel</em> of Lisp. Naturally, other people---particularly non-Lisp programmers---find this extremely off-putting.</p>
<p>There is a rational explanation of this phenomenon, however; as it so happens, the syntax of Lisp software, in practice, follows the structure of the central nervous system. Lisp models the brain. The mind, which is itself very much like software, recognizes this shared structure and responds positively to it. In other words, your mind, consciously or otherwise, sees itself and its underlying structure in Lisp as soon as it is able to make sense of what it is seeing, and as a result, awakens you to Lisp, just as you awakened once as a child the first time you looked into a mirror and realized you were seeing your own reflection. This is the moment you &#39;grok&#39; Lisp.</p>
<p>But it doesn&#39;t stop there---grokking is just the beginning of your Lisp journey. When the human brain and the computer are perfectly synchronized through a shared language that accurately models the underlying systems of both, the human mind naturally extends itself into the machine and experiences gestalt consciousness. The mind is capable of unconsciously understanding the structure of the computer through the Lisp language, and as such, is able to interface with the computer as if it was an extension to its own nervous system. This is Lisp Consciousness, where programmer and computer are one and the same; they drink of each other, and drink deep; and at least as long as the Lisp Hacker is there in the flow, riding the current of pure creativity and genius with their trusty companions Emacs and SLIME, neither programmer nor computer know where one ends and the other begins. In a manner of speaking, Lispers already know machine intelligence---and it is beautiful.</p>
<h3 id="Convergence-Theory-and-the-Technological-Singularity"><a href="#Convergence-Theory-and-the-Technological-Singularity" class="headerlink" title="Convergence Theory and the Technological Singularity"></a>Convergence Theory and the Technological Singularity</h3><p>(我真服了，大姐能不能、、、别这么神神叨叨，我真的害怕、、、有空再翻、、我看到这种b文章真的头大)</p>
<p>推动人类社会走向技术奇点点神秘力量，即人类与技术的真正完全统一，似乎也在将所有编程语言塑造成Lisp，把所有的电脑编程Lisp机器。lisp，毕竟可以做到任何事，用任何方式；that Lisp is not already the de-facto programming language is just a reflection of the state of the world as a whole---only a very small percentage of the population are excited for the technological singularity, but the singularity is coming no matter how much people complain. One way or another, every programmer is going to end up being a Lisper, because every programming language continues to adopt features and syntax from Lisp, one piece at a time. It is in every programmer&#39;s interest to master Lisp now, before the world at large realizes how essential Lisp will become over the next two decades.</p>
<p>Quantum Computing, the next big leap in computing and a fundamental aspect of the singularity, also currently happens to rely entirely on Lisp. There are efforts underway to adapt quantum computer programming to all sorts of languages and familiar syntaxes, but the only real quantum computers currently available are effectively Quantum Lisp Machines, and have their operating system written in Common Lisp. The power, simplicity, and elegance of Lisp really shines where it matters most: quantum computer programming is nearly impossible to understand unless you&#39;re a Lisp Hacker, but for a Lisp Hacker, it makes more sense than classical computing.</p>
<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><blockquote>
<p>&quot;Age is not an accomplishment, and youth is not a sin.&quot;</p>
<p>Robert A. Heinlein, <em>Methuselah&#39;s Children</em></p>
</blockquote>
<p>First, I would like to thank John McCarthy (1927--2011), the creator of LISP and father of modern AI. His insights into axiomatizing computation led to the ultimate expression of the symmetry between the human mind and the universe through the art of programming.</p>
<p>To the generations of Lisp Hackers before me, for keeping the language alive even through the dark years of the AI Winter, and for their excellent contributions to open-source software. And to all those who&#39;ve lent a hand proofreading the first and second drafts of this work, for their time and feedback.</p>
<p>And lastly, to Zed A. Shaw for creating and releasing to open-source the LxTHW package for writing your own Learn Code The Hard Way book, so that I could finally bring my ideas into being for a better Lisp book; he has already gone a long way on his own to improve programming education as a whole, and to make programming more accessible to people all over the world.</p>
<h1 id="PART-ONE-GROKKING-LISP"><a href="#PART-ONE-GROKKING-LISP" class="headerlink" title="PART ONE: GROKKING LISP"></a>PART ONE: GROKKING LISP</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote>
<p>&quot;&#39;Grok&#39; means to understand so thoroughly that the observer becomes a part of the process being observed—to merge, to blend, to intermarry, to lose personal identity in group experience. It means almost everything that we mean by religion, philosophy, and science—and it means as little to us as color means to a blind man.&quot;</p>
<p>Robert A. Heinlein, <em>Stranger in a Strange Land</em></p>
</blockquote>
<p>lisp不是一门你只是用来<em>学习</em>的语言，它会改变你，从程序员以及个人的角度。</p>
<p>在Part1，我们会专注Common lisp语言的核心，每天都会使用的功能以及能改变你查看编程的方式的技术。</p>
<p>我们会从整个语言的高层次概述开始，简单讲解一下语法细节，语义，风格，以及开发环境的设置。</p>
<p>然后是字符串，字符，读写；用户输入提示；列表，树以及特殊列表例如alists和plists;数学，向量和数组；词法范围和变量；以及函数。</p>
<p>接着我们将构建第一个应用，一个直截了当的文字冒险，将会用到在那之前所有学过的知识；把这些知识扩展到一个简单的网络程序和命令行工具，探索lisp更多高级特性，然后编写特定领域的语言，进一步掌控语法。</p>
<h2 id="Chapter-1-Common-Lisp-Bootcamp"><a href="#Chapter-1-Common-Lisp-Bootcamp" class="headerlink" title="Chapter 1: Common Lisp Bootcamp"></a>Chapter 1: Common Lisp Bootcamp</h2><blockquote>
<p>&quot;I made a very important discovery at Camp Currie. Happiness consists in getting enough sleep. Just that, nothing more. All the wealthy, unhappy people you&#39;ve ever met take sleeping pills; Mobile Infantrymen don&#39;t need them.&quot;</p>
<p>Robert A. Heinlein, <em>Starship Troopers</em></p>
</blockquote>
<p>(服了，兄弟，你要不要每章都插一句这位兄弟的话。。。神神叨叨的，无组织无纪律，这我不得不批评你一下了。)</p>
<p>是时候一个猛子扎进lisp了，不要犹豫。你需要自律来应用learning the hard的五个步骤，这也是你能感受到它的地方。不过要记住一件事(很多程序员在工作到筋疲力尽之前经常忘记它),在学习中最重要的事情是有一个良好的睡眠，每天如此，要准时休息。然后你第二天就可以精力充沛地醒来然后应付lisp。要有计划，并且严格执行，就像你老板说再迟到这个月不发工资然后你每天12点准时准点严格执行撅他祖坟这一任务一样。正确进食，在坐到电脑前先正常吃个早餐，努力工作，睡觉，然后你就会发现学习过程很顺利并且很有成效。</p>
<p>毕竟，这是有原因的，军方使用这一方法来训练---这是炼金术的一种隐晦的应用，在原子物理中实现：给予足够的热量和压力，实际上可以把铅转换为金。不过目前我们谈的是lisp。这里有让你正确进入lisp世界的一切东西，就在此刻。</p>
<h3 id="Syntax-Overview-in-5-Minutes"><a href="#Syntax-Overview-in-5-Minutes" class="headerlink" title="Syntax Overview in 5 Minutes"></a>Syntax Overview in 5 Minutes</h3><p>是什么让lisp家族语言如此简单，表达性强以及非常简洁呢，是语法。首先，lisp里的所有东西都是<em>对象</em>-所有对象都是用S-表达式表示的。</p>
<p>尽管其他变成语言普遍拥有独特的语法形式来表示改变内存中的一个值然后什么都不返回的<em>语句</em>，以及返回一个值的<em>表达式</em>。lisp使用S表达式来表示任何对象-所有的代码和数据，这就是所谓的&#39;同象性&#39;。结果是lisp里所有对象在被计算时都会有返回值。</p>
<p>S-表达式来自Lambda算子，它们的正式定义是一个<em>原子</em>或者一个<em>列表</em>。在lisp中，有一个或多个元素的列表被实现为Cons-Cells，然后原子就是除了cons的任何东西。Cons-Cells会在<a href="#The-REPL">这里</a>讨论。</p>
<p>下面是一些原子的例子-在REPL中自己尝试一下，记住，要和例子完全一样(就算你觉得这是错的)，在每一行的最后输入回车键。这是告诉lisp REPL执行你输入的表达式。</p>
<pre><code class="lisp">94

&#39;a-quoted-symbol

#\greek_small_letter_lamda

&quot;This is a string&quot;

nil

&#39;()

()

t
</code></pre>
<p>如你所见，在lisp中<em>原子</em>可以是很多东西-数字，符号，字符字面量，字符串，甚至是空列表。你可能注意到了，<code>nil</code>,<code>()</code>和<code>()</code>的返回值都是<code>NIL</code>。这是因为<code>nil</code>被定义为空列表，它被当作原子来处理，因为它不需要任何consing.但是在幕后有一些其他的诡计-例如字符串，当被当作原子处理时，实际上就是字符字面量序列；列表也是一种序列的子类。</p>
<p>要真正明白这里的内容，你需要记住有一个对象层次结构-lisp中的每个对象都继承自<code>t</code>-然后，所有东西都是对象。符号<code>nil</code>是一个特殊的例子，因为它是系统类<code>null</code>的唯一成员。只有<code>nil</code>和它的替代形式-空表，表示逻辑假。其他任何对象都是真值。你不需要返回<code>t</code>来表示函数返回的是真值，因为除了<code>nil</code>的其他值都是逻辑真，但是当你需要返回真值并且没有其他特殊的返回值的时候这还是有用的。</p>
<p>上面的例子中有一些前缀是单引号，这叫做<em>quoting(引用，我暂且这么翻译)</em>,这是让lisp不要执行引用的内容。你可以这么理解，这就是把表达式从代码转换为数据。前缀的单引号只是完整<code>引号</code>表达式的一种简短形式。让我们看一下关于引用表达式的更具体的例子:</p>
<pre><code class="lisp">&#39;()

&#39;(this is a list of symbols)

(quote (this is another list of symbols))

&#39;another-quoted-symbol
</code></pre>
<p>lisp中的列表被一对括号包裹起来。如果你之前看过lisp的源码并且很感兴趣，&quot;这些b括号是什么东西啊&quot;,现在就知道答案了。每一个嵌套在列表里的对象也是一个完全的S表达式，所以在一个给定的代码块中，你很容易在最后面找到大量的用来闭合所有列表形式的对象。</p>
<p>默认情况下，也就是没有被&quot;括起来&quot;,列表在执行时自动被当作代码处理，我们把这些列表叫做<em>form</em>.试一下:</p>
<pre><code class="lisp">(+ 10 20 (* 30 2))

(princ &quot;Hello, from Lisp!&quot;)

(loop for item in &#39;(this list will get printed in titlecase) do (format t &quot;~@(~A~) &quot; item))
</code></pre>
<p>目前对于输入的内容不要太操心-只需要确保准确输入，并且运行正确就行。运行结果应该是这样:</p>
<pre><code class="lisp">* (+ 10 20 (* 30 2))

90
* (princ &quot;Hello, from Lisp!&quot;)
Hello, from Lisp!
&quot;Hello, from Lisp!&quot;
* (loop for item in &#39;(this list will get printed in titlecase) do (format t &quot;~@(~A~) &quot; item))
This List Will Get Printed In Titlecase
NIL
*
</code></pre>
<p>看一下输入的内容然后思考一会。你会立即注意到一些东西(译者注，form可以被理解为表达式):</p>
<ul>
<li>一个form从函数，宏或者特殊操作符开始，通常是由一个运算符表示。</li>
<li>form剩下的部分由传递给函数，宏，或特殊运算符的参数组成。</li>
<li>可以用其他形式表示参数，并且最里层的表达式似乎被最先执行；结果被随后用作为上一层级的form的参数。</li>
</ul>
<p>这一语法叫做&quot;波兰前缀表达式&quot;-运算符在数据前面。在第一个例子中,<code>(+ 10 20 (* 30 2))</code>，显然，你传递了任意数量的数字给加法函数，然后你得到了总和。在这里，你还传递了<code>(* 30 2)</code>的返回值，也就是30乘2.所以和在其他用代数表达式的语言中写下像<code>10 + 20 + 30 * 2</code>这样的东西不一样，你只需要输入一次加法符号，并且操作顺序很清楚。像这样简单的例子，看起来可能没啥，但是对于现实里的软件，这可以极大地简化代码。</p>
<p>通常在表达式中位于运算符位置的是一个符号，表示一个命名函数，但它也可以是匿名函数，宏，或者特殊的表达式。特殊表达式有其特定的规则，也没有提供方法来定义新的特殊表达式。除此以外，宏允许你创建自定义的语法，让你任意扩展和修改lisp语言。不过一般来说你会写函数，类和方法到你的日常代码中，这些知识简单地扩展了语言的语义。</p>
<p>除此以外还有一些<code>reader 宏</code>，可以让你定义表达式，数据类型的简便形式。你已经见过这东西了-比如<code>quote</code>的简写，由一个引号表示，在表达式前加一个单引号来防止它被执行。</p>
<p>利用这一神奇的简便语法，你可以使用任何你选择的编程范式表示任何你想得到的程序。</p>
<h3 id="The-REPL"><a href="#The-REPL" class="headerlink" title="The REPL"></a>The REPL</h3><p>lisp REPL --- 一个读取-执行-输出循环 ---是交互式开发lisp的核心。你输入了一个表达式，表达式被读取，执行，然后打印返回值，接着REPL等待下一次输入。REPL被一个提示标记着，就像你操作系统的命令行，这也是你目前运行的lisp容器的主界面。根据你用的lisp实现，你可以看到不同的提示。还可以自定义提示，但是这些做法取决于具体的lisp实现。</p>
<p>想象一下下划线是你闪烁的指针，你会看到这个:</p>
<pre><code class="lisp">CL-USER&gt; _
</code></pre>
<p>但是在SBCL,默认的提示没那么显眼:</p>
<pre><code class="lisp">* _
</code></pre>
<p>方便起见，当你需要输入一段代码并且在REPL中立即执行时，每行代码都会被一个SBCL提示字符标记。当你输入文件中的所有代码时，每行前面就没有提示符了，你会被要求输入文件名。</p>
<p>记住，不要在REPL中输入提示符<code>*</code>;即使你的提示符不是<code>*</code>，<code>*</code>表示所有的common lisp repl提示符。例如你会经常看到像这样的代码例子:</p>
<pre><code class="lisp">* (+ 1 1)

2
* (apply #&#39;+ 1 2 3 4 &#39;(5 6))

21
</code></pre>
<p>上面的例子表示，先输入表达式<code>(+ 1 1)</code>;执行然后返回<code>2</code>，这就是你想要的输出。然后你回到终端，输入表达式<code>(apply #&#39;+ 1 2 3 4 &#39;(5 6))</code>，返回了<code>21</code>。如果你从命令行使用SBCL，这会直接显示会话的记录-在表达式和返回值之间有一个额外的换行符。如果你用的是Emacs+SLIME，就没有这个额外的换行符。</p>
<p>许多lisp作品和参考用一个胖箭头<code>=&gt;</code>明确标记了返回值。这能让例子中的返回值更容易被发现。我们也会采用这一诱人的小窍门，在有必要的时候。这种情况下，上面的例子看起来是这样的:</p>
<pre><code class="lisp">* (+ 1 1)
=&gt; 2
* (apply #&#39;+ 1 2 3 4 &#39;(5 6))
=&gt; 21
</code></pre>
<p>在大多数练习中，我们会把代码例子分成两部分:首先是你需要输入的，然后是正确的返回值，用来和你的那个比较。</p>
<h3 id="Expressions-Parentheses-and-Return-Values"><a href="#Expressions-Parentheses-and-Return-Values" class="headerlink" title="Expressions, Parentheses, and Return Values"></a>Expressions, Parentheses, and Return Values</h3><p>迂腐地讲，你在REPL或者lisp源码中输入的任何东西都会被读取或扩展成S表达式，然后执行。引用(也就是前缀加个单引号)是一种令嵌套的S表达式不被执行的方式，但是有一些S表达式永远不会被执行。如果你的Lisp解释器不能把你的输入识别成有效的S表达式，一般会进入到调试器中，就像它尝试执行但是失败了一样。</p>
<pre><code class="lisp">* (+ 1 1)
=&gt; 2 ;; as expected, because it&#39;s a valid S-Expression
* &#123;+ 1 1&#125;
;; this won&#39;t evaluate, because the Lisp reader doesn&#39;t recognize braces
</code></pre>
<p>Common Lisp只有S表达式；指令式编程语言，举个例子，会区分&#39;语句&#39;和&#39;表达式&#39;,语句会改变环境但没有返回值，而表达式的值就是其返回值。基于lisp语言家族的传统，语法被设计成极简化-所以在lisp中，就算是一个破坏性的原地操作也以S表达式的形式表现。为了方便，破坏性的原地操作的名字前缀带有一个&quot;N&quot;,为了显式表示它们具有副作用:</p>
<pre><code class="lisp">;; first lets define a couple variables
* (defvar *test-list-a* (list 1 2 3))
* (defvar *test-list-b* (list &#39;d &#39;e &#39;f))
;; append returns a new list from its arguments
* (append *test-list-a* *test-list-b*)
=&gt; (1 2 3 D E F)
;; you can see that the original lists haven&#39;t changed
* *test-list-a*
=&gt; (1 2 3)
* *test-list-b*
=&gt; (D E F)
;; but now lets do a destructive operation, NCONC (ie, in-place list concatenation)
* (nconc *test-list-a* *test-list-b*)
=&gt; (1 2 3 D E F)
;; the variable&#39;s binding and assignment haven&#39;t changed, but the last cons-cell
;; now points to *test-list-b* instead of terminating at NIL
* *test-list-a*
=&gt; (1 2 3 D E F)
</code></pre>
<p>从抽象层面来讲，表达式被期望有一个返回值；在common lisp中的s表达式几乎都是这样，不过也有一些例外。例如一个函数调用，函数体内的最后一个form的值被当作整个函数的返回值:</p>
<pre><code class="lisp">;; this is a typical anonymous function call; the last form in its body is (+ x x)
;; so the function call returns (+ 2 2) =&gt; 4
* ((lambda (x) (+ x x)) 2)
=&gt; 4
;; in this function, the return result of (+ x x) is not assigned so it is essentially
;; lost; the function body moves on to the next form, (* x x), which is the last form
;; of this function body. So the function call only returns (* 10 10) =&gt; 100
* ((lambda (x) (+ x x) (* x x)) 10)
=&gt; 100
;; in this function, we capture the return values of both (+ x x) and (* x x), as the
;; lexical variables SUM and PRODUCT; using VALUES, we can return multiple values from
;; a form instead of just one
* ((lambda (x) (let ((sum (+ x x)) (product (* x x))) (values sum product))) 10)
=&gt; 20 100
;; but calling VALUES without anything gives us... an expression with no return result!
* (values)
=&gt; ; No value
</code></pre>
<p>之前提到过，S表达式要么是原子要么是<em>Cons-Cell</em>。Cons-Cells are represented by Lists to the Reader and by the Printer-但是空列表被当作原子处理，因为它不需要构造。</p>
<p>原子有一个子集叫做<em>自求值对象</em>。因为表达式被期望有返回值，这些特定的对象就返回它们自身。通过引用一个表达式，你就把一个引用表达式转换成了自求值对象(什么b玩意)。</p>
<pre><code class="lisp">;; these are some self-evaluating objects:
;; strings---
* &quot;a string&quot;
;; characters---
* #\greek_small_letter_lamda
;; numbers
* 42
* #x2A
;; bit-vectors---
* #*1001
</code></pre>
<p>注意:<code>#x2A</code>好像返回了一些不太一样的东西，但实际上没有-十进制的<code>42</code>和16进制的<code>#x2A</code>是同一个数字。可以通过<code>(eq 42 #x2A)</code>来证明。</p>
<p>列表是被一对括号包裹的S表达式的有序集合，其中的元素被空格分割-空格的数量没有影响，但是对于如何规范你的代码有一些比较严格的约定，这会在下一章详细讨论。重申一下，非空列表被当作cons-cells，然后cons-cells会以列表的形式打印出来。但是列表同样是lisp中的一个正确数据类型，理解<em>表示</em>和<em>执行</em>之间的区别很重要。</p>
<pre><code class="lisp">;; this:
&#39;(a b c)
;; is the same as this:
&#39;(a
  b
  c)
;; and this:
(list &#39;a &#39;b &#39;c)
</code></pre>
<p>当列表被<em>处理</em>的时候，除非被引用，否则一律当成代码。列表在被当作代码处理时，其元素的位置在语法和语义层面上都有意义。位置的概念会在后面的&quot;Prefix Notation&quot;章节中讨论.</p>
<p>Lisp代码注定是简洁且优美的；如果你发现自己盯着混乱的括号发呆，那么你的代码就复杂到难以管理了。本书也展示了一些分解和重构的方法，你可以学到如何写出漂亮优雅的程序，就像Common Lisp语言本身一样。</p>
<h3 id="Lists-Cons-Cells-and-Memory"><a href="#Lists-Cons-Cells-and-Memory" class="headerlink" title="Lists, Cons-Cells, and Memory"></a>Lists, Cons-Cells, and Memory</h3><p>在学习lisp的时候，请注意S表达式的表现方式和实现方式的区别-从麦卡锡关于lisp的第一篇论文，S表达式由它们的表现形式所定义，而在common lisp，S表达式由其实现方式所定义，并且它们的表现形式只被当作其底层对象的一个接口。</p>
<p>列表是一个合适的类型，继承自Lisp的类型层次结构中的序列。列表只有在有数据能被构造的时候才会构造。举个例子:</p>
<pre><code class="lisp">* (list)
=&gt; NIL
* (list &#39;a)
=&gt; (A)
* (list &#39;a nil)
=&gt; (A NIL)
* (cons &#39;a nil)
=&gt; (A)
</code></pre>
<p>为了理解上面那个例子，你需要理解什么是构造,以及列表是如何在Cons-Cells之上构建的。</p>
<pre><code class="lisp">;; this:
(list &#39;a &#39;b &#39;c)
;; is the same as this:
(cons &#39;a (cons &#39;b (cons &#39;c nil)))
;; while this:
(list &#39;a &#39;nil)
;; is the same as this:
(cons &#39;a (cons nil nil))
</code></pre>
<p>cons-cells链通常结束于<code>nil</code>，但是你也可以把一个cons-cell的cdr指针指向一个值，并且使用点表示法来简写:</p>
<pre><code class="lisp">;; this:
&#39;(a . b)
;; is the same as this:
(cons &#39;a &#39;b)
</code></pre>
<p>像这样的一组点表示法对被叫做关联列表，或者简称<code>alist</code>。这是在Lisp中可用于存储键&#x2F;值对的许多数据结构中的一种，并且有一个不错的API。</p>
<pre><code class="lisp">&#39;((a . b)
  (c . d)
  (e . f))
</code></pre>
<p>所以你会问，我一直在说的&quot;Cons-Cell&quot;到底是什么b玩意呢？</p>
<p>一个Cons-Cell对象包含一对指针，<code>car</code>和<code>cdr</code>-即为&quot;Contents of Address Register&quot;和&quot;Contents of Decrement Register&quot;各自的缩略词。<code>car</code>通常是一个指向一个值的指针，然后<code>cdr</code>可能是指向另一个cons-cell的<code>car</code>指针的指针，或者是指向<code>NIL</code>的指针，抑或在dotted-pair的情况下，指向另一个值。</p>
<p>再思考一下上面的例子。现在你可以更清晰的观察到列表是如何在Cons-Cell链之上构建的，以及你直接使用Cons-Cells会发生什么:</p>
<pre><code class="lisp">;; this creates three cons-cells, the quoted symbols &#39;A, &#39;B, and &#39;C each in the CAR of their own Cons-Cell
(list &#39;a &#39;b &#39;c)
;; it would be the same as typing this:
(cons &#39;a (cons &#39;b (cons &#39;c nil)))
;; or this:
&#39;(a . (b . (c . nil)))
;; or this:
&#39;(a b c . nil)
;; or simply this:
&#39;(a b c)
</code></pre>
<p>Lisp源代码优化的一个普遍关注点是最小化应用所执行的构造的数量。请注意一个dotted-pair只会构造一次，而一个包含相同数据的列表会构造两次；所以使用<code>alist</code>而不是其他基于list的数据结构例如<code>plist</code>，就已经节省了一半的内存和处理需求。</p>
<h3 id="Symbols-and-Namespaces"><a href="#Symbols-and-Namespaces" class="headerlink" title="Symbols and Namespaces"></a>Symbols and Namespaces</h3><p>Common Lisp通常指的是LISP<sub>2</sub>-也就是说，在任何给定的环境内函数和变量的命名空间是分开的。原则上，这表示你可以同时把一个函数和变量绑定和赋值到符号<code>foo</code>上，执行<code>(foo foo)</code>，然后lisp可以通过它们在form中的位置自动区分函数和变量。你还可以在参数的位置使用reader宏<code>#&#39;</code>来显式调用一个函数，例如<code>(apply #&#39;foo foo)</code>。不过事实上这被认为是一种糟糕的form。请看下面的例子:</p>
<pre><code class="lisp">(defvar foo 1)

(defun foo (foo)
  (+ foo foo))

(foo foo)
=&gt; 2
</code></pre>
<p>上面的例子中，有3种不同的数据关联到符号<code>foo</code>。首先是用<code>defvar</code>分配值<code>1</code>到全局变量<code>foo</code>上。然后是一个函数定义<code>foo</code>，并且它有一个参数也叫<code>foo</code>。在<code>foo</code>的函数体内，是它的参数再加上它自身；所以当函数<code>foo</code>被应用到全局变量<code>foo</code>时，会得到<code>(+ 1 1) =&gt; 2</code>。</p>
<p>这是因为Common Lisp除了有分开的函数和变量的命名空间，还是动态和词法范围的。动态域在common lisp里是特殊且显式的；而词法域更直观，不过比较隐晦-换句话说，你需要特别声明一个符号是特殊的，以便在一个词法范围内使用它的动态绑定，而在这个范围内符号可以被词法绑定并被分配为不同的变量，而许多form引入了一个隐含的词法域。因此对于顶级动态变量有一个命名惯例，叫做&quot;earmuffs(耳罩)&quot;:</p>
<pre><code class="lisp">;; top-level, dynamic variables can be declared with DEFVAR or DEFPARAMETER
(defvar *my-dynamic-var* &quot;I&#39;m special!&quot;)
=&gt; *MY-DYNAMIC-VAR*
;; notice that the variable names are qualified with a pair of asterisks? These are called earmuffs.
(defparameter *my-extra-special-dynamic-var* &quot;I&#39;m special, too!&quot;)
=&gt; *MY-EXTRA-SPECIAL-DYNAMIC-VAR*
;; one obvious way to introduce a lexical scope is with a LET form for binding and assigning lexical variables:
(let ((one 1)
      (two 2)
      (three 3))
  (+ one two three))
=&gt; 6
;; now let&#39;s put them both together
(defvar *one* 1)
=&gt; *ONE*
(let ((one 1.0))
  (+ one *one*))
=&gt; 2.0
</code></pre>
<p>&quot;耳罩&quot;把特殊变量和词法区别开来。即使这&quot;只是一种惯例&quot;，这是你一定要遵循的。函数和变量独立的命名空间，和符号的动态和词法的作用域结合起来，非常牛逼哈-但是它很容易失控。用耳罩标记特殊的动态变量是一种很有效的手段。</p>
<p>驯服Common Lisp的原始力量的另一个杰出特性是它的<em>包</em>系统，能让你为环境指定自定义read-tables。当你定义了一个包，需要显示引入位于包的命名空间里的你想要的符号-即使是common lisp语言本身的符号;你可以在包定义体里使用<code>:use</code>关键字表达式来一次性引入一个包里所有导出的符号。</p>
<p>为了完全探索包系统，请创建一个叫做<code>ex1-1-5.lisp</code>的文件，然后输入以下内容:</p>
<p>你还可以在包里继续定义一些函数，变量，类，方法还有其他代码，以及在包定义的<code>:export</code>关键字表达式里具体列出你想要导出的符号，作为包的公共接口。注意在这个包的定义中，还定义了一个包的昵称<code>newpack</code>,并且告诉它在MY-NEW-PACKAGE本地read-table里<code>use</code>所有COMMON-LISP和COMMON-LISP-USER包里的导出的符号。</p>
<p>现在回到命令行,进入你刚刚创建的文件的路径，然后，在Linux或者Mac上运行:</p>
<pre><code class="sh">$ rlwrap sbcl --load &quot;ex1-1-5.lisp&quot;
</code></pre>
<p>在windows上运行:</p>
<pre><code class="sh">$ sbcl --load &quot;ex1-1-5.lisp&quot;
</code></pre>
<p>这会把你的源代码文件读取并编译到lisp镜像里，通常你会获得<code>COMMON-LISP-USER</code>包里的提示符。如果你想检查一下你在哪个包里，可以输入<code>*package*</code>。</p>
<p>你可以在当前的lisp镜像里使用任何绑定的符号，通过它的全名-一般来说当你输入一个符号的名字，并不需要输入它从属的包的命名空间。Lisp会假设你输入的符号位于当前的包里，除非你特别指定。你<em>可以</em>访问包里的任何符号，即使它没有被导出，但是最好遵守一下库开发者的显式条约，使用包导出的接口而不是内部内容。</p>
<p>考虑到你已经在<code>my-new-package</code>里定义了<code>mad-adder</code>函数并且导入了文件，不过在打开REPL的时候实际在使用<code>cl-user</code>包，你可能会想你可以直接调用<code>mad-adder</code>-但很可惜，你只会得到一个错误，因为<code>mad-adder</code>的<em>全名</em>实际上是<code>my-new-package:mad-adder</code>而不是<code>common-lisp-user:mad-adder</code>。可以使用这个包的昵称，能少打点字而且也很清晰:</p>
<pre><code class="lisp">;; this:
(newpack:mad-adder 1)
;; is the same as:
(my-new-package:mad-adder 1)
;; if a symbol isn&#39;t exported, however, you have to use two colons between the package and symbol
newpack::*my-private-var*
</code></pre>
<p>有一些符号的名字你不能用，至少在没有耍花招的前提下。一个普遍规则是，不要把COMMON-LISP包里的978个外部符号的任何一个用于函数或者变量，即使那个绑定不在Common Lisp标准里。COMMON-LISP包里导出的符号的名字是<em>保留的</em>。</p>
<h3 id="Prefix-Notation"><a href="#Prefix-Notation" class="headerlink" title="Prefix Notation"></a>Prefix Notation</h3><p>一个被求值的列表表达式有语法上和语义上都有意义的位置。请记住，列表的实现是Cons-Cells.所以一个被求值的列表的car指针需要指向一个有意义的操作符;cdr指针指向操作符的一系列参数，这叫做<em>parameters</em>(尼玛....arguments和parameters不都是参数的意思吗，中文里没有同义词啊卧槽尼玛).换句话说，操作符在前，而不是中缀表示法(也就是代数计数法).这叫做&quot;波兰前缀表示法&quot;.</p>
<pre><code class="lisp">;; Polish Prefix notation, the operator comes first:
(operator . (list of parameters))
</code></pre>
<p>举个例子，你想要一系列数字的累加和。通常你会这么写:<code>1+2+3...</code>,把操作符放在参数之间;但是在lisp中要这么写:</p>
<pre><code class="lisp">* (+ 1 2 3 4 5)
=&gt; 15
</code></pre>
<p>在lisp中，不需要在数字之间写一些多余的加号<code>+</code>.你在给函数传递参数，函数知道把参数收集起来然后求和。这是lisp和其他语言在概念上的巨大差异-当先写操作符时，你是告诉计算机<em>你想要什么</em>而不是<em>做什么,以及怎么做</em>.在上面的例子中，你告诉lisp你想要1到5点数字和，而不是告诉它1+2，然后把结果加上3，然后4,5...你看出来这之间的区别了吗?</p>
<p>有效的操作符可以是表示一个函数，宏，特殊操作符,或者一个匿名函数的lambda表达式的<em>符号</em>(他妈的作者你说的简短点会变成50g小盒子吗?)。如果是一个符号，lisp解释器首先会检查其是否是特殊的操作符，如果不是，就在read-table里寻找一个符合定义的函数。宏比较高端-他们可以反复扩展成普通的lisp代码;reader宏在读取时(read-time,我也不懂这啥意思,随便翻了)被扩展，而<code>defmacro</code>form在编译的时候扩展。有很多技术用来控制宏在何时还有何地被扩展。</p>
<p>如何处理参数具体取决于操作符的类型。例如函数，从任何参数表达式中只能获取一个单独的返回值，特殊的操作符有自己的规则。宏允许你任意更改lisp的语法和语义-所以，显然这些规则由宏定义form自身来决定。如何使用宏在lisp社区里是一个有争议的话题。</p>
<h3 id="Common-Lisp-Style-Guide"><a href="#Common-Lisp-Style-Guide" class="headerlink" title="Common Lisp Style Guide"></a>Common Lisp Style Guide</h3><p>风格是写代码的基础-尤其对于lisp，这可以让范式无限的power和灵活性涌入你的大脑。一点点的粗心就可以让你的代码变得马虎，漏洞百出；但是如果你能够把你的代码当成一种艺术和能够完成工作的工具，你和以后看你代码的人都会因此而感激你。</p>
<p>但是也不要犯了教条主义的错误；并且也不是lisp社区里的所有人都赞同这个。更倾向于把这些当作能让你考虑代码风格的切实建议，然后你和你的团队可以一起决定哪种风格符合你的编码审美，让你想要遵循。</p>
<p>在学习lisp的这一阶段，你可能不会完全认可这里给出的风格约定，或者理解这里讨论的内容。这没关系。深呼吸，然后尽可能地熟悉这些内容，把这一章当作参考；这意味着在完成每一章的学习后你会掌握越来越多本章的内容，然后会演变成你每一个lisp项目都会参考的东西。</p>
<h4 id="Symblos-and-Naming"><a href="#Symblos-and-Naming" class="headerlink" title="Symblos and Naming"></a>Symblos and Naming</h4><p>代码里清晰且有意义的符号名是代码可读性最重要的部分之一。</p>
<p>虽然在common lisp标准里有一些非硬性规则用于命名符号，但除了一个允许使用的字符列表之外，lisp里出现了一些你应该知道并且通常要认真遵循的惯例。有些时候你可以，可能也不得不，打破条例，但是那些特殊情况需要经验和技巧。</p>
<p>符号名应该具有描述性，简短，小写，然后单词由一个**-**连接:</p>
<pre><code class="lisp">(defun my-addition-function (&amp;rest rest)
  (apply #&#39;+ rest))
=&gt; MY-ADDITION-FUNCTION

(deftype my-integer-type ()
  &#39;(and integer
        (satisfies plusp)))
=&gt; MY-INTEGER-TYPE

(defvar my-hash-table (make-hash-table :test &#39;equal))
=&gt; MY-HASH-TABLE

(defvar my-alist &#39;((&quot;one&quot; . 1)
                   (&quot;two&quot; . 2)
                   (&quot;three&quot; . 3)))
=&gt; MY-ALIST

;; Note that symbol names created from strings should be in all-caps:
(intern &quot;MY-NEW-INTERNED-SYMBOL&quot;)
=&gt; MY-NEW-INTERNED-SYMBOL
   NIL
;; or you&#39;ll have to reference it in surrounding hbars as a literal, case-sensitive symbol:
(intern &quot;my-funky-interned-symbol&quot;)
=&gt; |my-funky-interned-symbol|
   NIL
</code></pre>
<p>注意一对hbars(什么b东西，真没懂这个词啥意思)是语义性的，不是某种风格。这允许你定义大小写敏感的符号；但是这一半用在外部函数接口。</p>
<p>全局变量,<em>i.e</em>,在最顶级用<code>defvar</code>或者<code>defparameter</code>定义的变量，要用&quot;耳罩&quot;裹起来因为他们是动态的而且很特殊，就像内置在common lisp里的:</p>
<pre><code class="lisp">*package*
=&gt; #&lt;PACKAGE &quot;COMMON-LISP-USER&quot;&gt;
*print-base*
=&gt; 10
</code></pre>
<p>加耳罩是风格。不会被lisp解释器解析为语义token，只是作为符号名字的一部分被读取。</p>
<p>另一个风格惯例用于常量的名字是在两边放个<code>+</code>号:</p>
<pre><code class="lisp">(defconstant +my-new-constant+ 1.0)
</code></pre>
<p>包内部的符号有时候</p>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">



<script src="/js/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>

<div id="footer"></div>
 
</body>